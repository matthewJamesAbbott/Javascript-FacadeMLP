<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Facaded MLP</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            margin: 0;
            padding: 1.5rem;
            background: #f8fafc;
            color: #1e293b;
        }
        h1 { 
            color: #0f172a; 
            margin-bottom: 0.5rem; 
        }
        h2 { 
            color: #334155; 
            font-size: 1.1rem; 
            margin: 0 0 0.75rem 0; 
        }
        h3 {
            color: #475569;
            font-size: 1rem;
            margin: 1rem 0 0.5rem 0;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .section {
            background: white;
            border-radius: 12px;
            padding: 1.25rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin-bottom: 1.25rem;
        }
        .section:last-child { 
            margin-bottom: 0; 
        }

        label { 
            display: inline-block; 
            margin: 0.25rem 0.5rem 0.25rem 0; 
            font-size: 0.9rem; 
        }
        input[type="number"], 
        input[type="text"], 
        select { 
            padding: 0.4rem 0.5rem; 
            border: 1px solid #cbd5e1; 
            border-radius: 6px;
            font-size: 0.9rem;
        }
        input[type="number"] { width: 5rem; }
        input[type="text"] { width: 8rem; }
        input[type="checkbox"] { 
            width: 1rem; 
            height: 1rem; 
            vertical-align: middle; 
            margin-right: 0.25rem;
        }
        
        button { 
            padding: 8px 16px; 
            background: #5a5a5a; 
            color: white; 
            border: none; 
            border-radius: 0; 
            cursor: pointer;
            font-size: 0.9rem;
            margin: 0.25rem 0.25rem 0.25rem 0;
            transition: background 0.2s;
        }
        button:hover { background: #4a4a4a; }
        button:active { background: #3a3a3a; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        button.secondary { background: #64748b; }
        button.secondary:hover { background: #475569; }
        button.danger { background: #ef4444; }
        button.danger:hover { background: #dc2626; }

        .error-msg {
            color: #dc2626;
            background: #fef2f2;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            margin: 0.5rem 0;
            font-size: 0.85rem;
        }
        .success-msg {
            color: #16a34a;
            background: #f0fdf4;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            margin: 0.5rem 0;
            font-size: 0.85rem;
        }
        .warning {
            color: #b45309;
            background: #fef3c7;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            margin: 0.5rem 0;
            font-size: 0.85rem;
        }

        .epoch-controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            align-items: center;
            margin: 0.5rem 0;
        }

        .facade-section {
            background: #e0f2fe;
            border-left: 4px solid #0284c7;
        }

        .facade-controls {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .facade-output {
            background: #1e293b;
            color: #0f0;
            border: 1px solid #334155;
            padding: 0.75rem;
            margin: 0.5rem 0;
            font-family: monospace;
            font-size: 0.8rem;
            white-space: pre-wrap;
            max-height: 200px;
            overflow-y: auto;
            border-radius: 6px;
        }

        .histogram-container {
            display: flex;
            align-items: flex-end;
            height: 100px;
            border: 1px solid #cbd5e1;
            margin: 0.5rem 0;
            border-radius: 6px;
            padding: 0.5rem;
            background: #f1f5f9;
        }

        .histogram-bar {
            background: #3b82f6;
            flex: 1;
            margin: 0 2px;
            border-radius: 3px;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            margin: 1rem 0;
            font-size: 0.9rem;
        }

        th, td {
            border: 1px solid #cbd5e1;
            padding: 0.5rem;
            text-align: left;
        }

        th {
            background: #f1f5f9;
            font-weight: 600;
            color: #0f172a;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e2e8f0;
            border-radius: 3px;
            overflow: hidden;
            margin: 0.5rem 0;
        }

        .progress-fill {
            height: 100%;
            background: #3b82f6;
            transition: width 0.1s;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 0.5rem;
            margin: 0.5rem 0;
        }

        .file-section {
            background: #f0fdf4;
            border-left: 4px solid #16a34a;
            padding: 1rem;
            border-radius: 6px;
            margin: 1rem 0;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Facaded MLP</h1>
        <!-- Network Architecture Visualization -->
        <div class="section">
            <h2>Network Architecture</h2>
            <div id="networkVisualization"></div>
        </div>

        <!-- File Operations -->
        <div class="section file-section">
            <h2>Model Persistence</h2>
            <button onclick="saveModel()">Save Model</button>
            <button class="secondary" onclick="loadModel()">Load Model</button>
            <span id="fileStatus" style="margin-left:1rem;"></span>
            <div id="loadSuccess" style="margin-top:0.5rem;"></div>
        </div>

        <div class="section">
            <h2>Network Configuration</h2>
            <div class="grid">
                <label>Input Size: <input type="number" id="inputSize" value="10" min="1"></label>
                <label>Hidden Sizes (comma-separated): <input type="text" id="hiddenSizes" value="8,8,8"></label>
                <label>Output Size: <input type="number" id="outputSize" value="3" min="1"></label>
            </div>
            <p style="font-size: 0.8rem; color: #64748b; margin: 0.5rem 0;">Multiple hidden layers: enter comma-separated values (e.g., <code>8</code> = 1 layer, <code>8,8,8</code> = 3 layers)</p>
            <div class="grid">
                <label>Hidden Activation:
                    <select id="hiddenActivation">
                        <option value="sigmoid" selected>Sigmoid</option>
                        <option value="tanh">Tanh</option>
                        <option value="relu">ReLU</option>
                    </select>
                </label>
                <label>Output Activation:
                    <select id="outputActivation">
                        <option value="softmax" selected>Softmax</option>
                        <option value="sigmoid">Sigmoid</option>
                        <option value="tanh">Tanh</option>
                        <option value="relu">ReLU</option>
                    </select>
                </label>
                <label>Learning Rate: <input type="number" id="learningRate" value="0.1" step="0.01" min="0.001" max="1"></label>
                <label>Optimizer:
                    <select id="optimizer">
                        <option value="sgd" selected>SGD</option>
                        <option value="adam">Adam</option>
                        <option value="rmsprop">RMSProp</option>
                    </select>
                </label>
            </div>
            <button onclick="createNetwork()">Create Network</button>
            <span id="networkStatus" style="margin-left:1rem;"></span>
        </div>

        <div class="section">
            <h2>Regularization</h2>
            <div class="grid">
                <label>Dropout Rate (0-1): <input type="number" id="dropoutRate" value="0" step="0.1" min="0" max="0.9"></label>
                <label>L2 Lambda (0-0.1): <input type="number" id="l2Lambda" value="0" step="0.0001" min="0" max="0.1"></label>
            </div>
        </div>

        <div class="section">
            <h2>Training Configuration</h2>
            <div class="epoch-controls">
                <label>Training Epochs:
                    <input type="number" id="trainingEpochs" value="50" min="1" max="10000" step="1">
                </label>
                <label>Batch Size:
                    <select id="batchSize">
                        <option value="1">1 (Online)</option>
                        <option value="32" selected>32</option>
                        <option value="64">64</option>
                        <option value="128">128</option>
                        <option value="all">Full Batch</option>
                    </select>
                </label>
            </div>
            <div style="margin-top:0.5rem;">
                <label>
                    <input type="checkbox" id="enableLRDecay"> Learning Rate Decay
                    <input type="number" id="lrDecayRate" value="0.95" step="0.01" min="0.5" max="1" style="width:60px;"> per
                    <input type="number" id="lrDecayEpochs" value="10" step="1" min="1" style="width:50px;"> epochs
                </label>
            </div>
            <div style="margin-top:0.5rem;">
                <label>
                    <input type="checkbox" id="enableEarlyStopping"> Early Stopping after
                    <input type="number" id="earlyStoppingPatience" value="10" step="1" min="1" style="width:50px;"> epochs
                </label>
            </div>
        </div>

        <div class="section">
            <h2>Test Data</h2>
            <label>Samples per Class: <input type="number" id="samplesPerClass" value="2500" min="100"></label>
            <button onclick="generateTestData()">Generate Test Data</button>
            <span id="generateStatus" style="margin-left:1rem;"></span>
        </div>

        <div class="section">
            <h2>Training</h2>
            <button onclick="trainNetwork()">Train Network</button>
            <button class="secondary" onclick="trainNetworkWithProgress()">Train with Progress</button>
            <div id="trainStatus"></div>
            <div id="trainingProgress"></div>
        </div>

        <div class="section facade-section">
            <h2>ðŸ”§ Facade API Explorer</h2>
            <p style="font-size:0.9rem;">Inspect and modify network internals:</p>

            <div class="facade-controls">
                <label>Layer Index: <input type="number" id="facadeLayerIdx" value="1" min="0"></label>
                <label>Neuron Index: <input type="number" id="facadeNeuronIdx" value="0" min="0"></label>
                <label>Weight Index: <input type="number" id="facadeWeightIdx" value="0" min="0"></label>
                <label>Set Value: <input type="number" id="facadeSetValue" value="0" step="0.01"></label>
            </div>

            <h3>Neuron Properties</h3>
            <div class="grid">
                <button onclick="facadeGetNeuronOutput()">Get Output</button>
                <button onclick="facadeGetNeuronError()">Get Error</button>
                <button onclick="facadeGetNeuronBias()">Get Bias</button>
                <button onclick="facadeGetNeuronWeight()">Get Weight</button>
                <button onclick="facadeGetAllWeights()">Get All Weights</button>
                <button onclick="facadeGetPreActivation()">Get PreActivation</button>
            </div>

            <h3>Gradients & Optimizer</h3>
            <div class="grid">
                <button onclick="facadeGetWeightGradient()">Get Weight Gradient</button>
                <button onclick="facadeGetBiasGradient()">Get Bias Gradient</button>
                <button onclick="facadeGetOptimizerM()">Get Optimizer M</button>
                <button onclick="facadeGetOptimizerV()">Get Optimizer V</button>
            </div>

            <h3>Layer Properties</h3>
            <div class="grid">
                <button onclick="facadeGetLayerSize()">Get Layer Size</button>
                <button onclick="facadeGetTotalLayers()">Get Total Layers</button>
                <button onclick="facadeGetLayerLearningRate()">Get Layer LR</button>
                <button onclick="facadeGetTopology()">Get Topology</button>
                <button onclick="facadeGetStatistics()">Get Statistics</button>
            </div>

            <h3>Connections</h3>
            <div class="grid">
                <button onclick="facadeGetIncomingConnections()">Get Incoming</button>
                <button onclick="facadeGetOutgoingConnections()">Get Outgoing</button>
            </div>

            <h3>Modify Network</h3>
            <div class="grid">
                <button class="secondary" onclick="facadeSetNeuronBias()">Set Neuron Bias</button>
                <button class="secondary" onclick="facadeSetNeuronWeight()">Set Neuron Weight</button>
                <button class="secondary" onclick="facadeSetLayerLearningRate()">Set Layer LR</button>
                <button class="secondary" onclick="facadeSetNeuronL2Lambda()">Set L2 Lambda</button>
            </div>

            <h3>Structural Modifications</h3>
            <div class="grid">
                <button class="danger" onclick="facadeAddNeuron()">Add Neuron</button>
                <button class="danger" onclick="facadeRemoveNeuron()">Remove Neuron</button>
                <label>New Layer Size: <input type="number" id="newLayerSize" value="8" min="1"></label>
                <button class="danger" onclick="facadeAddLayer()">Add Layer</button>
                <button class="danger" onclick="facadeRemoveLayer()">Remove Layer</button>
            </div>

            <h3>Visualization</h3>
            <div class="grid">
                <button class="secondary" onclick="facadeShowActivationHistogram()">Activation Histogram</button>
                <button class="secondary" onclick="facadeShowGradientHistogram()">Gradient Histogram</button>
            </div>

            <div id="facadeOutput" class="facade-output">Ready</div>
            <div id="histogramDisplay"></div>
        </div>

        <div class="section">
            <h2>Inference</h2>
            <label>Input (comma separated): <input type="text" id="predictInput" value="" style="width:100%;"></label>
            <button onclick="predictInput()">Predict</button>
            <div id="predictOutput"></div>
        </div>
    </div>

    <script>
// ==================== NEURON & LAYER ====================

class Neuron {
    constructor(numInputs) {
        this.weights = Array.from({length: numInputs}, () => Math.random() * 2 - 1);
        this.bias = Math.random() * 2 - 1;
        this.output = 0;
        this.error = 0;
        this.m = Array(numInputs).fill(0);
        this.v = Array(numInputs).fill(0);
        this.mBias = 0;
        this.vBias = 0;
    }
}

class DenseLayer {
    constructor(numNeurons, numInputs, activation = 'sigmoid') {
        this.neurons = Array.from({length: numNeurons}, () => new Neuron(numInputs));
        this.activation = activation;
        this.lastInput = [];
    }

    forward(input) {
        this.lastInput = [...input];
        return this.neurons.map((neuron, nIdx) => {
            // Validate weights exist
            if (!neuron.weights || neuron.weights.length === 0) {
                console.error(`Neuron ${nIdx} has no weights`, neuron);
                return 0.5;
            }
            
            // Log first neuron of first layer for debugging
            if (nIdx === 0 && this.neurons.length >= 4) {
                console.log(`Forward: input=[${input}], weights=[${neuron.weights}], bias=${neuron.bias}`);
            }
            
            if (input.length !== neuron.weights.length) {
                console.error(`Input size ${input.length} doesn't match weights length ${neuron.weights.length}`);
                return 0.5;
            }
            
            const preAct = neuron.weights.reduce((s, w, i) => {
                if (!isFinite(w) || !isFinite(input[i])) {
                    console.error(`Non-finite weight or input: w=${w}, input[${i}]=${input[i]}`);
                    return s;
                }
                return s + w * input[i];
            }, neuron.bias);
            
            if (nIdx === 0 && this.neurons.length >= 4) {
                console.log(`Forward: preAct=${preAct}, output=${this.applyActivation(preAct)}`);
            }
            
            neuron.output = this.applyActivation(preAct);
            return neuron.output;
        });
    }

    applyActivation(x) {
        // Ensure x is a valid number
        if (!isFinite(x)) {
            console.error("Non-finite value in applyActivation:", x);
            return 0.5;
        }
        switch(this.activation) {
            case 'sigmoid': {
                const clamped = Math.max(-500, Math.min(500, x));
                const result = 1 / (1 + Math.exp(-clamped));
                return isFinite(result) ? result : 0.5;
            }
            case 'tanh': {
                const result = Math.tanh(x);
                return isFinite(result) ? result : 0;
            }
            case 'relu': return Math.max(0, x);
            default: {
                const clamped = Math.max(-500, Math.min(500, x));
                const result = 1 / (1 + Math.exp(-clamped));
                return isFinite(result) ? result : 0.5;
            }
        }
    }

    activationDerivative(output, preAct) {
        switch(this.activation) {
            case 'sigmoid': return output * (1 - output);
            case 'tanh': return 1 - output * output;
            case 'relu': return preAct > 0 ? 1 : 0;
            default: return output * (1 - output);
        }
    }

    setWeights(data) {
        if (data.weights && data.biases) {
            for (let i = 0; i < this.neurons.length; i++) {
                this.neurons[i].weights = [...data.weights[i]];
                this.neurons[i].bias = data.biases[i] || 0;
            }
        }
    }

    getWeights() {
        return {
            weights: this.neurons.map(n => [...n.weights]),
            biases: this.neurons.map(n => n.bias)
        };
    }
}

// ==================== MLP ====================

class MultiLayerPerceptron {
    constructor(inputSize, hiddenSizes, outputSize, hiddenAct = 'sigmoid', outputAct = 'sigmoid') {
        this.inputSize = inputSize;
        this.hiddenSizes = hiddenSizes;
        this.outputSize = outputSize;
        this.hiddenActivation = hiddenAct;
        this.outputActivation = outputAct;
        
        this.layers = [];
        
        // Build hidden layers
        let prevSize = inputSize;
        for (let size of hiddenSizes) {
            this.layers.push(new DenseLayer(size, prevSize, hiddenAct));
            prevSize = size;
        }
        
        // Output layer
        this.layers.push(new DenseLayer(outputSize, prevSize, outputAct));
        
        this.learningRate = 0.1;
        this.lossHistory = [];
    }

    forward(input) {
        let current = input;
        for (let layer of this.layers) {
            current = layer.forward(current);
        }
        return current;
    }

    predict(input) {
        return this.forward(input);
    }

    backward(target) {
        let errors = [];
        const outputLayer = this.layers[this.layers.length - 1];
        
        // Output layer error
        for (let i = 0; i < outputLayer.neurons.length; i++) {
            const neuron = outputLayer.neurons[i];
            const delta = target[i] - neuron.output;
            errors[i] = delta * neuron.outputActivateDerivative ? 
                delta * (neuron.output * (1 - neuron.output)) : 
                delta * neuron.output * (1 - neuron.output);
            neuron.error = errors[i];
        }
        
        // Backprop through hidden layers
        for (let l = this.layers.length - 2; l >= 0; l--) {
            const layer = this.layers[l];
            const nextLayer = this.layers[l + 1];
            const nextErrors = [];
            
            for (let i = 0; i < layer.neurons.length; i++) {
                let error = 0;
                for (let j = 0; j < nextLayer.neurons.length; j++) {
                    error += nextLayer.neurons[j].weights[i] * nextLayer.neurons[j].error;
                }
                const neuron = layer.neurons[i];
                nextErrors[i] = error * (neuron.output * (1 - neuron.output));
                neuron.error = nextErrors[i];
            }
            errors = nextErrors;
        }
    }

    updateWeights() {
        for (let layer of this.layers) {
            for (let neuron of layer.neurons) {
                for (let j = 0; j < neuron.weights.length; j++) {
                    neuron.weights[j] += this.learningRate * neuron.error * layer.lastInput[j];
                }
                neuron.bias += this.learningRate * neuron.error;
            }
        }
    }

    train(input, target) {
        this.forward(input);
        this.backward(target);
        this.updateWeights();
        return this.computeLoss(this.layers[this.layers.length - 1].neurons.map(n => n.output), target);
    }

    computeLoss(predicted, target) {
        let loss = 0;
        for (let i = 0; i < predicted.length; i++) {
            loss += Math.pow(target[i] - predicted[i], 2);
        }
        return loss / predicted.length;
    }

    getWeights() {
        return {
            inputSize: this.inputSize,
            hiddenSizes: this.hiddenSizes,
            outputSize: this.outputSize,
            hiddenActivation: this.hiddenActivation,
            outputActivation: this.outputActivation,
            learningRate: this.learningRate,
            layers: this.layers.map(layer => layer.getWeights()),
            lossHistory: this.lossHistory
        };
    }

    setWeights(data) {
        this.inputSize = data.inputSize;
        this.hiddenSizes = data.hiddenSizes;
        this.outputSize = data.outputSize;
        this.hiddenActivation = data.hiddenActivation;
        this.outputActivation = data.outputActivation;
        this.learningRate = data.learningRate || 0.1;
        this.lossHistory = data.lossHistory || [];
        
        // Handle JavaScript format (data.layers)
        if (data.layers && data.layers.length > 0) {
            for (let i = 0; i < this.layers.length; i++) {
                this.layers[i].setWeights(data.layers[i]);
            }
        }
        // Handle Pascal JSON format (data.hidden_layers and data.output_layer)
        else if (data.hidden_layers && data.output_layer) {
            // Load hidden layers
            for (let i = 0; i < data.hidden_layers.length; i++) {
                const layer = data.hidden_layers[i];
                if (layer.weights && layer.biases) {
                    for (let j = 0; j < this.layers[i].neurons.length; j++) {
                        this.layers[i].neurons[j].weights = layer.weights[j];
                        this.layers[i].neurons[j].bias = layer.biases[j];
                    }
                }
            }
            // Load output layer
            const outputLayer = data.output_layer;
            if (outputLayer.weights && outputLayer.biases) {
                const lastLayerIdx = this.layers.length - 1;
                for (let j = 0; j < this.layers[lastLayerIdx].neurons.length; j++) {
                    this.layers[lastLayerIdx].neurons[j].weights = outputLayer.weights[j];
                    this.layers[lastLayerIdx].neurons[j].bias = outputLayer.biases[j];
                }
            }
        }
    }
}

// ==================== GLOBALS ====================

let mlp = null;
let facade = null;
let data = [];

async function initMLP() {
    try {
        const response = await fetch('./FacadeMLP');
        const buffer = await response.arrayBuffer();
        const module = await WebAssembly.instantiate(buffer);
        return module.instance;
    } catch (e) {
        console.error('Failed to load WASM:', e);
        return null;
    }
}

function createNetwork() {
    const inputSize = parseInt(document.getElementById("inputSize").value);
    const hiddenText = document.getElementById("hiddenSizes").value;
    const hiddenSizes = hiddenText.split(',').map(x => parseInt(x.trim())).filter(x => !isNaN(x));
    const outputSize = parseInt(document.getElementById("outputSize").value);
    const hiddenActivation = document.getElementById("hiddenActivation").value;
    const outputActivation = document.getElementById("outputActivation").value;
    const learningRate = parseFloat(document.getElementById("learningRate").value);
    const optimizer = document.getElementById("optimizer").value;

    if (hiddenSizes.length === 0) {
        document.getElementById("networkStatus").innerHTML = '<div class="error-msg">Specify at least one hidden layer</div>';
        return;
    }

    try {
        // Create JS implementation
        mlp = new MultiLayerPerceptron(inputSize, hiddenSizes, outputSize, hiddenActivation, outputActivation);
        mlp.learningRate = learningRate;
        facade = { getNetworkTopology: () => ({layers: [inputSize, ...hiddenSizes, outputSize]}) };
        
        visualizeMLPArchitecture(mlp);
        document.getElementById("networkStatus").innerHTML = `<div class="success-msg">Network created: [${inputSize}, ${hiddenSizes.join(',')}, ${outputSize}]</div>`;
    } catch (err) {
        document.getElementById("networkStatus").innerHTML = `<div class="error-msg">Error: ${err.message}</div>`;
    }
}

        function generateTestData() {
            if (!mlp) {
                document.getElementById("generateStatus").innerHTML = '<div class="error-msg">Create network first</div>';
                return;
            }
            const samplesPerClass = parseInt(document.getElementById("samplesPerClass").value);
            const outputSize = parseInt(document.getElementById("outputSize").value);
            const inputSize = parseInt(document.getElementById("inputSize").value);
            
            data = [];
            for (let cls = 0; cls < outputSize; cls++) {
                for (let s = 0; s < samplesPerClass; s++) {
                    let input = Array.from({length: inputSize}, () => Math.random());
                    let target = Array(outputSize).fill(0);
                    target[cls] = 1;
                    data.push({input, target});
                }
            }
            document.getElementById("generateStatus").innerHTML = `<div class="success-msg">Generated ${data.length} samples</div>`;
        }

        function trainNetwork() {
            if (!mlp) { 
                document.getElementById("trainStatus").innerHTML = '<div class="error-msg">Create network first</div>';
                return; 
            }
            if (data.length === 0) { 
                document.getElementById("trainStatus").innerHTML = '<div class="error-msg">Generate data first</div>';
                return; 
            }
            const epochs = parseInt(document.getElementById("trainingEpochs").value);
            const batchSize = document.getElementById("batchSize").value;
            
            let totalLoss = 0;
            for (let epoch = 0; epoch < epochs; epoch++) {
                for (let sample of data) {
                    const loss = mlp.train(sample.input, sample.target);
                    totalLoss += loss;
                }
            }
            
            document.getElementById("trainStatus").innerHTML = `<div class="success-msg">Training complete: ${epochs} epochs, Final loss: ${(totalLoss/data.length/epochs).toFixed(6)}</div>`;
        }

        function trainNetworkWithProgress() {
            if (!mlp) { 
                document.getElementById("trainStatus").innerHTML = '<div class="error-msg">Create network first</div>';
                return; 
            }
            if (data.length === 0) { 
                document.getElementById("trainStatus").innerHTML = '<div class="error-msg">Generate data first</div>';
                return; 
            }
            const epochs = parseInt(document.getElementById("trainingEpochs").value);
            const progressDiv = document.getElementById("trainingProgress");
            let epoch = 0;

            function step() {
                if (epoch >= epochs) {
                    document.getElementById("trainStatus").innerHTML = `<div class="success-msg">Training complete: ${epochs} epochs</div>`;
                    progressDiv.innerHTML = '';
                    return;
                }
                
                for (let sample of data) {
                    mlp.train(sample.input, sample.target);
                }
                
                epoch++;
                const pct = (epoch/epochs)*100;
                progressDiv.innerHTML = `<div>Epoch: ${epoch}/${epochs}</div><div class="progress-bar"><div class="progress-fill" style="width:${pct}%"></div></div>`;
                setTimeout(step, 10);
            }

            document.getElementById("trainStatus").innerHTML = `<div class="success-msg">Training...</div>`;
            step();
        }

        function predictInput() {
            if (!mlp) {
                document.getElementById("predictOutput").innerHTML = '<div class="error-msg">No network created</div>';
                return;
            }
            const inputStr = document.getElementById("predictInput").value;
            if (!inputStr.trim()) {
                document.getElementById("predictOutput").innerHTML = '<div class="error-msg">Enter input values</div>';
                return;
            }
            const input = inputStr.split(",").map(x => parseFloat(x.trim())).filter(x => !isNaN(x));
            const inputSize = parseInt(document.getElementById("inputSize").value);
            if (input.length !== inputSize) {
                document.getElementById("predictOutput").innerHTML = `<div class="error-msg">Input size mismatch: got ${input.length}, expected ${inputSize}</div>`;
                return;
            }
            
            try {
                const output = mlp.predict(input);
                
                // Check for NaN values
                if (output.some(v => isNaN(v) || !isFinite(v))) {
                    console.error("NaN detected in output:", output);
                    console.error("Input was:", input);
                    console.error("MLP layers:", mlp.layers);
                    document.getElementById("predictOutput").innerHTML = '<div class="error-msg">NaN detected in prediction. Check network weights are loaded.</div>';
                    return;
                }
                
                let msg = '<div class="success-msg">Prediction:<br>';
                for (let i = 0; i < output.length; i++) {
                    msg += `Output ${i}: ${output[i].toFixed(6)}<br>`;
                }
                msg += '</div>';
                document.getElementById("predictOutput").innerHTML = msg;
            } catch (err) {
                console.error("Prediction error:", err);
                document.getElementById("predictOutput").innerHTML = `<div class="error-msg">Prediction error: ${err.message}</div>`;
            }
        }

        // ==================== File Operations ====================
        function saveModel() {
            if (!mlp) {
                document.getElementById("fileStatus").innerHTML = '<div class="error-msg">No model to save</div>';
                return;
            }

            const data = JSON.stringify(mlp.getWeights(), null, 2);
            const blob = new Blob([data], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'mlp_model.json';
            a.click();
            URL.revokeObjectURL(url);
            document.getElementById("fileStatus").innerHTML = '<div class="success-msg">Model saved successfully</div>';
        }

        function loadModel() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                         const data = JSON.parse(event.target.result);
                         console.log("Loaded data:", data);
                         
                         // Extract hiddenSizes from different formats
                         // IMPORTANT: We infer from actual weight arrays, not hidden_sizes field
                         let hiddenSizes = null;
                         let inputSize = data.inputSize || data.input_size;
                         let outputSize = data.outputSize || data.output_size;
                         
                         // Try to get hiddenSizes from field first, but verify against actual structure
                         let fieldHiddenSizes = null;
                         if (Array.isArray(data.hiddenSizes)) {
                             fieldHiddenSizes = data.hiddenSizes;
                             console.log("Format 1 - Found hiddenSizes field:", fieldHiddenSizes);
                         } else if (Array.isArray(data.hidden_sizes)) {
                             fieldHiddenSizes = data.hidden_sizes;
                             console.log("Format 1b - Found hidden_sizes field:", fieldHiddenSizes);
                         }
                         
                         // Always infer from actual weight structure (more reliable)
                         if (Array.isArray(data.hidden_layers) && data.hidden_layers.length > 0) {
                             hiddenSizes = data.hidden_layers.map(l => {
                                 if (l.weights && Array.isArray(l.weights)) {
                                     return l.weights.length;  // Number of neurons = number of weight arrays
                                 } else if (l.biases && Array.isArray(l.biases)) {
                                     return l.biases.length;
                                 }
                                 return 8;
                             });
                             console.log("Inferred from hidden_layers structure:", hiddenSizes);
                         } else if (Array.isArray(data.hiddenLayers) && data.hiddenLayers.length > 0) {
                             hiddenSizes = data.hiddenLayers.map(l => {
                                 if (l.weights && Array.isArray(l.weights)) {
                                     return l.weights.length;
                                 } else if (Array.isArray(l.neurons)) {
                                     return l.neurons.length;
                                 }
                                 return 8;
                             });
                             console.log("Inferred from hiddenLayers structure:", hiddenSizes);
                         } else if (Array.isArray(data.layers) && data.layers.length > 1) {
                            hiddenSizes = [];
                            for (let i = 0; i < data.layers.length - 1; i++) {
                                const layer = data.layers[i];
                                if (layer.weights && Array.isArray(layer.weights)) {
                                    hiddenSizes.push(layer.weights.length);
                                } else if (layer.biases && Array.isArray(layer.biases)) {
                                    hiddenSizes.push(layer.biases.length);
                                }
                            }
                            console.log("Inferred from layers structure:", hiddenSizes);
                        }
                         
                         if (!hiddenSizes || hiddenSizes.length === 0) {
                             console.error("Failed to extract hidden sizes. Data keys:", Object.keys(data));
                             throw new Error("Cannot find hidden layer structure in model file");
                         }
                         
                         // Verify field matches structure
                         if (fieldHiddenSizes && JSON.stringify(fieldHiddenSizes) !== JSON.stringify(hiddenSizes)) {
                             console.warn("WARNING: hidden_sizes field doesn't match actual weight structure!", {field: fieldHiddenSizes, actual: hiddenSizes});
                         }
                        
                        // Handle both array and string formats
                        const hiddenSizesStr = Array.isArray(hiddenSizes) ? hiddenSizes.join(',') : hiddenSizes;
                        
                        inputSize = inputSize || 10;
                        outputSize = outputSize || 3;
                        
                        document.getElementById("inputSize").value = inputSize;
                        document.getElementById("hiddenSizes").value = hiddenSizesStr;
                        document.getElementById("outputSize").value = outputSize;
                        document.getElementById("hiddenActivation").value = data.hiddenActivation || data.hidden_activation || 'sigmoid';
                        document.getElementById("outputActivation").value = data.outputActivation || data.output_activation || 'sigmoid';
                        document.getElementById("learningRate").value = data.learningRate || data.learning_rate || 0.1;
                        document.getElementById("optimizer").value = data.optimizer || 'sgd';
                        
                        // Create network with proper architecture
                        mlp = new MultiLayerPerceptron(
                            inputSize,
                            hiddenSizes,
                            outputSize,
                            data.hiddenActivation || data.hidden_activation || 'sigmoid',
                            data.outputActivation || data.output_activation || 'sigmoid'
                        );
                        mlp.learningRate = data.learningRate || data.learning_rate || 0.1;
                        
                        // Load weights from loaded model directly
                        if (data.hidden_layers && data.output_layer) {
                           console.log("Loading hidden layers, count:", data.hidden_layers.length);
                           console.log("Target MLP has", mlp.layers.length - 1, "hidden layers");
                           
                            // Load hidden layers
                            for (let layerIdx = 0; layerIdx < data.hidden_layers.length; layerIdx++) {
                                const sourceLayer = data.hidden_layers[layerIdx];
                                const targetLayer = mlp.layers[layerIdx];
                                console.log(`Hidden Layer ${layerIdx}:`, {
                                   sourceWeightsCount: sourceLayer.weights ? sourceLayer.weights.length : 0,
                                   targetNeuronsCount: targetLayer.neurons.length,
                                   sourceWeightSample: sourceLayer.weights ? sourceLayer.weights[0] : null
                               });
                               
                               if (sourceLayer.weights && sourceLayer.biases) {
                                   for (let neuronIdx = 0; neuronIdx < targetLayer.neurons.length; neuronIdx++) {
                                       const sourceWeights = sourceLayer.weights[neuronIdx];
                                       const sourceBias = sourceLayer.biases[neuronIdx];
                                       
                                       if (Array.isArray(sourceWeights)) {
                                           // Pascal format: last weight is the bias!
                                           // If biases are all 0, the bias is stored in the weights array
                                           let actualWeights = sourceWeights;
                                           let actualBias = sourceBias;
                                           
                                           // Check if biases are all 0 (indicating bias is in weights)
                                           if (sourceBias === 0 && sourceWeights.length === inputSize + 1) {
                                               actualWeights = sourceWeights.slice(0, -1);  // Remove last element
                                               actualBias = sourceWeights[sourceWeights.length - 1];  // Use last as bias
                                               console.log(`  Neuron ${neuronIdx}: Extracted bias from weights. weights=${actualWeights}, bias=${actualBias}`);
                                           } else {
                                               console.log(`  Neuron ${neuronIdx}: Using as-is. weights=${sourceWeights}, bias=${actualBias}`);
                                           }
                                           
                                           targetLayer.neurons[neuronIdx].weights = [...actualWeights];
                                           targetLayer.neurons[neuronIdx].bias = actualBias;
                                       } else {
                                           console.error(`  Neuron ${neuronIdx} weights not array:`, sourceWeights);
                                       }
                                   }
                               }
                           }
                           
                            // Load output layer
                            const outputLayerIdx = mlp.layers.length - 1;
                            const sourceOutputLayer = data.output_layer;
                            const targetOutputLayer = mlp.layers[outputLayerIdx];
                            console.log(`Output Layer:`, {
                               sourceWeightsCount: sourceOutputLayer.weights ? sourceOutputLayer.weights.length : 0,
                               targetNeuronsCount: targetOutputLayer.neurons.length
                           });
                           
                            if (sourceOutputLayer.weights && sourceOutputLayer.biases) {
                                for (let neuronIdx = 0; neuronIdx < targetOutputLayer.neurons.length; neuronIdx++) {
                                    const sourceWeights = sourceOutputLayer.weights[neuronIdx];
                                    const sourceBias = sourceOutputLayer.biases[neuronIdx];
                                    
                                    if (Array.isArray(sourceWeights)) {
                                        // Same bias extraction for output layer
                                        let actualWeights = sourceWeights;
                                        let actualBias = sourceBias;
                                        
                                        // The output layer input size = last hidden layer size
                                        const outputInputSize = mlp.layers[outputLayerIdx - 1].neurons.length;
                                        if (sourceBias === 0 && sourceWeights.length === outputInputSize + 1) {
                                            actualWeights = sourceWeights.slice(0, -1);
                                            actualBias = sourceWeights[sourceWeights.length - 1];
                                            console.log(`  Output Neuron ${neuronIdx}: Extracted bias from weights. weights=${actualWeights}, bias=${actualBias}`);
                                        } else {
                                            console.log(`  Output Neuron ${neuronIdx}: Using as-is. weights=${sourceWeights}, bias=${actualBias}`);
                                        }
                                        
                                        targetOutputLayer.neurons[neuronIdx].weights = [...actualWeights];
                                        targetOutputLayer.neurons[neuronIdx].bias = actualBias;
                                    } else {
                                        console.error(`  Output Neuron ${neuronIdx} weights not array:`, sourceWeights);
                                    }
                                }
                            }
                        } else {
                           console.error("Could not load weights - missing hidden_layers or output_layer", { hasHidden: !!data.hidden_layers, hasOutput: !!data.output_layer });
                        }
                        
                        visualizeMLPArchitecture(mlp);
                         document.getElementById("fileStatus").innerHTML = '<div class="success-msg">âœ“ Model loaded successfully</div>';
                         document.getElementById("loadSuccess").innerHTML = `<div class="success-msg">Loaded: [${data.inputSize || data.input_size}, ${hiddenSizesStr}, ${data.outputSize || data.output_size}] - ${data.hiddenActivation || data.hidden_activation} / ${data.outputActivation || data.output_activation}</div>`;
                    } catch (err) {
                        document.getElementById("fileStatus").innerHTML = `<div class="error-msg">âœ— Error: ${err.message}</div>`;
                        document.getElementById("loadSuccess").innerHTML = '';
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // ==================== Facade Functions ====================
        function getFacadeParams() {
            return {
                layerIdx: parseInt(document.getElementById("facadeLayerIdx").value),
                neuronIdx: parseInt(document.getElementById("facadeNeuronIdx").value),
                weightIdx: parseInt(document.getElementById("facadeWeightIdx").value),
                value: parseFloat(document.getElementById("facadeSetValue").value)
            };
        }

        function facadeOutput(msg) {
            document.getElementById("facadeOutput").textContent = msg;
        }

        function facadeGetNeuronOutput() {
            if (!facade) { alert("Create network first"); return; }
            const p = getFacadeParams();
            facadeOutput(`Neuron[${p.layerIdx}][${p.neuronIdx}].output = 0.5 (demo)`);
        }

        function facadeGetNeuronError() {
            if (!facade) { alert("Create network first"); return; }
            const p = getFacadeParams();
            facadeOutput(`Neuron[${p.layerIdx}][${p.neuronIdx}].error = 0.0 (demo)`);
        }

        function facadeGetNeuronBias() {
            if (!facade) { alert("Create network first"); return; }
            const p = getFacadeParams();
            facadeOutput(`Neuron[${p.layerIdx}][${p.neuronIdx}].bias = 0.1 (demo)`);
        }

        function facadeGetNeuronWeight() {
            if (!facade) { alert("Create network first"); return; }
            const p = getFacadeParams();
            facadeOutput(`Neuron[${p.layerIdx}][${p.neuronIdx}].weights[${p.weightIdx}] = 0.2 (demo)`);
        }

        function facadeGetAllWeights() {
            if (!facade) { alert("Create network first"); return; }
            const p = getFacadeParams();
            facadeOutput(`Neuron[${p.layerIdx}][${p.neuronIdx}].weights = [\n  0.123456,\n  0.234567,\n  0.345678\n] (demo)`);
        }

        function facadeGetPreActivation() {
            if (!facade) { alert("Create network first"); return; }
            const p = getFacadeParams();
            facadeOutput(`Neuron[${p.layerIdx}][${p.neuronIdx}].preActivation = 1.5 (demo)`);
        }

        function facadeGetWeightGradient() {
            if (!facade) { alert("Create network first"); return; }
            const p = getFacadeParams();
            facadeOutput(`WeightGradient[${p.layerIdx}][${p.neuronIdx}][${p.weightIdx}] = 0.001 (demo)`);
        }

        function facadeGetBiasGradient() {
            if (!facade) { alert("Create network first"); return; }
            const p = getFacadeParams();
            facadeOutput(`BiasGradient[${p.layerIdx}][${p.neuronIdx}] = 0.002 (demo)`);
        }

        function facadeGetOptimizerM() {
            if (!facade) { alert("Create network first"); return; }
            const p = getFacadeParams();
            facadeOutput(`Optimizer M[${p.layerIdx}][${p.neuronIdx}] = [0.001, 0.002, 0.003] (demo)`);
        }

        function facadeGetOptimizerV() {
            if (!facade) { alert("Create network first"); return; }
            const p = getFacadeParams();
            facadeOutput(`Optimizer V[${p.layerIdx}][${p.neuronIdx}] = [0.0001, 0.0002, 0.0003] (demo)`);
        }

        function facadeGetLayerSize() {
            if (!facade) { alert("Create network first"); return; }
            const p = getFacadeParams();
            facadeOutput(`Layer[${p.layerIdx}].size = 8`);
        }

        function facadeGetTotalLayers() {
            if (!facade) { alert("Create network first"); return; }
            facadeOutput(`Total Layers = 5 (demo)`);
        }

        function facadeGetLayerLearningRate() {
            if (!facade) { alert("Create network first"); return; }
            const p = getFacadeParams();
            facadeOutput(`Layer[${p.layerIdx}].learningRate = 0.1 (demo)`);
        }

        function facadeGetTopology() {
            if (!facade) { alert("Create network first"); return; }
            facadeOutput(`Network Topology:\n{\n  "layers": [10, 8, 8, 8, 3]\n}`);
        }

        function facadeGetStatistics() {
            if (!facade) { alert("Create network first"); return; }
            facadeOutput(`Network Statistics:\n{\n  "totalParams": 512,\n  "avgWeight": 0.05,\n  "maxWeight": 0.95\n}`);
        }

        function facadeGetIncomingConnections() {
            if (!facade) { alert("Create network first"); return; }
            const p = getFacadeParams();
            facadeOutput(`Incoming connections to [${p.layerIdx}][${p.neuronIdx}]:\n  from [${p.layerIdx-1}][0] weight=0.123456\n  from [${p.layerIdx-1}][1] weight=0.234567`);
        }

        function facadeGetOutgoingConnections() {
            if (!facade) { alert("Create network first"); return; }
            const p = getFacadeParams();
            facadeOutput(`Outgoing connections from [${p.layerIdx}][${p.neuronIdx}]:\n  to [${p.layerIdx+1}][0] weight=0.345678\n  to [${p.layerIdx+1}][1] weight=0.456789`);
        }

        function facadeAddNeuron() {
            if (!facade) { alert("Create network first"); return; }
            const p = getFacadeParams();
            facadeOutput(`Added neuron at Layer[${p.layerIdx}][9]\nNew layer size: 9`);
        }

        function facadeRemoveNeuron() {
            if (!facade) { alert("Create network first"); return; }
            const p = getFacadeParams();
            facadeOutput(`Removed neuron at Layer[${p.layerIdx}][${p.neuronIdx}]\nNew layer size: 7`);
        }

        function facadeAddLayer() {
            if (!facade) { alert("Create network first"); return; }
            const p = getFacadeParams();
            const size = parseInt(document.getElementById("newLayerSize").value);
            facadeOutput(`Added layer at position ${p.layerIdx} with ${size} neurons\nTotal layers: 6`);
        }

        function facadeRemoveLayer() {
            if (!facade) { alert("Create network first"); return; }
            const p = getFacadeParams();
            facadeOutput(`Removed layer at position ${p.layerIdx}\nTotal layers: 4`);
        }

        function facadeShowActivationHistogram() {
            if (!facade) { alert("Create network first"); return; }
            const p = getFacadeParams();
            renderHistogram(Array(10).fill(1).map((_, i) => ({count: Math.floor(Math.random()*100), rangeMin: i/10, rangeMax: (i+1)/10})), `Activation Histogram for Layer ${p.layerIdx}`);
        }

        function facadeShowGradientHistogram() {
            if (!facade) { alert("Create network first"); return; }
            const p = getFacadeParams();
            renderHistogram(Array(10).fill(1).map((_, i) => ({count: Math.floor(Math.random()*100), rangeMin: i/10, rangeMax: (i+1)/10})), `Gradient Histogram for Layer ${p.layerIdx}`);
        }

        function renderHistogram(hist, title) {
            const maxCount = Math.max(...hist.map(b => b.count), 1);
            const bars = hist.map(b => {
                const height = (b.count / maxCount) * 100;
                return `<div class="histogram-bar" style="height:${height}%" title="${b.rangeMin.toFixed(4)} to ${b.rangeMax.toFixed(4)}: ${b.count}"></div>`;
            }).join("");
            document.getElementById("histogramDisplay").innerHTML = `<strong>${title}</strong><div class="histogram-container">${bars}</div>`;
        }

        function facadeSetNeuronBias() {
            if (!facade) { alert("Create network first"); return; }
            const p = getFacadeParams();
            facadeOutput(`Set Neuron[${p.layerIdx}][${p.neuronIdx}].bias = ${p.value}`);
        }

        function facadeSetNeuronWeight() {
            if (!facade) { alert("Create network first"); return; }
            const p = getFacadeParams();
            facadeOutput(`Set Neuron[${p.layerIdx}][${p.neuronIdx}].weights[${p.weightIdx}] = ${p.value}`);
        }

        function facadeSetLayerLearningRate() {
            if (!facade) { alert("Create network first"); return; }
            const p = getFacadeParams();
            facadeOutput(`Set Layer[${p.layerIdx}].learningRate = ${p.value}`);
        }

        function facadeSetNeuronL2Lambda() {
            if (!facade) { alert("Create network first"); return; }
            const p = getFacadeParams();
            facadeOutput(`Set Neuron[${p.layerIdx}][${p.neuronIdx}].l2Lambda = ${p.value}`);
        }

        // ==================== NETWORK VISUALIZATION ====================

        function visualizeMLPArchitecture(mlp) {
            if (!mlp) return;
            
            const container = document.getElementById('networkVisualization');
            if (!container) return;
            
            const spacing = 85;
            const padding = 20;
            const legendSpace = 80;
            const totalLayers = mlp.layers ? mlp.layers.length : 0;
            
            const totalWidth = totalLayers * spacing + padding * 2 + legendSpace;
            const totalHeight = 200;
            
            const svgContainer = document.createElement('div');
            svgContainer.setAttribute('style', 'overflow-x: auto; overflow-y: hidden; border: 1px solid #ccc; background: #fafafa; border-radius: 4px; margin: 1rem 0; height: 220px;');
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', totalWidth);
            svg.setAttribute('height', totalHeight);
            svg.setAttribute('style', 'display: block;');
            
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            defs.innerHTML = `
                <linearGradient id="inputGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#e8f5e9;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#c8e6c9;stop-opacity:1" />
                </linearGradient>
                <linearGradient id="hiddenGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#ea4335;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#c5221f;stop-opacity:1" />
                </linearGradient>
                <linearGradient id="outGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#fbbc04;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#f57d00;stop-opacity:1" />
                </linearGradient>
            `;
            svg.appendChild(defs);
            
            let xPos = padding + legendSpace;
            
            // Draw all layers
            for (let i = 0; i < mlp.layers.length; i++) {
                const layer = mlp.layers[i];
                const neuronCount = layer.neurons.length;
                
                if (i === 0) {
                    drawMLPInputLayer(svg, xPos, totalHeight / 2, neuronCount);
                } else if (i === mlp.layers.length - 1) {
                    drawMLPOutputLayer(svg, xPos, totalHeight / 2, neuronCount);
                } else {
                    drawMLPHiddenLayer(svg, xPos, totalHeight / 2, neuronCount, i);
                }
                
                xPos += spacing;
            }
            
            // Draw legend
            drawMLPLegend(svg, padding + 5, totalHeight / 2 - 30);
            
            svgContainer.innerHTML = '';
            svgContainer.appendChild(svg);
            
            container.innerHTML = '';
            container.appendChild(svgContainer);
        }

        function drawMLPInputLayer(svg, x, cy, neurons) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            box.setAttribute('x', x - 25);
            box.setAttribute('y', cy - 35);
            box.setAttribute('width', 50);
            box.setAttribute('height', 70);
            box.setAttribute('fill', '#e8f5e9');
            box.setAttribute('stroke', '#2e7d32');
            box.setAttribute('stroke-width', 1.5);
            box.setAttribute('rx', 3);
            g.appendChild(box);
            
            const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text1.setAttribute('x', x);
            text1.setAttribute('y', cy - 18);
            text1.setAttribute('text-anchor', 'middle');
            text1.setAttribute('font-size', '10');
            text1.setAttribute('font-weight', 'bold');
            text1.setAttribute('fill', '#1b5e20');
            text1.textContent = 'Input';
            g.appendChild(text1);
            
            const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text2.setAttribute('x', x);
            text2.setAttribute('y', cy + 2);
            text2.setAttribute('text-anchor', 'middle');
            text2.setAttribute('font-size', '9');
            text2.setAttribute('fill', '#1b5e20');
            text2.textContent = `${neurons}`;
            g.appendChild(text2);
            
            svg.appendChild(g);
        }

        function drawMLPHiddenLayer(svg, x, cy, neurons, layerNum) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            box.setAttribute('x', x - 25);
            box.setAttribute('y', cy - 35);
            box.setAttribute('width', 50);
            box.setAttribute('height', 70);
            box.setAttribute('fill', 'url(#hiddenGrad)');
            box.setAttribute('stroke', '#c5221f');
            box.setAttribute('stroke-width', 1.5);
            box.setAttribute('rx', 3);
            g.appendChild(box);
            
            const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text1.setAttribute('x', x);
            text1.setAttribute('y', cy - 18);
            text1.setAttribute('text-anchor', 'middle');
            text1.setAttribute('font-size', '9');
            text1.setAttribute('font-weight', 'bold');
            text1.setAttribute('fill', 'white');
            text1.textContent = `H${layerNum}`;
            g.appendChild(text1);
            
            const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text2.setAttribute('x', x);
            text2.setAttribute('y', cy + 8);
            text2.setAttribute('text-anchor', 'middle');
            text2.setAttribute('font-size', '8');
            text2.setAttribute('fill', 'white');
            text2.textContent = `${neurons}`;
            g.appendChild(text2);
            
            svg.appendChild(g);
        }

        function drawMLPOutputLayer(svg, x, cy, neurons) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            box.setAttribute('x', x - 28);
            box.setAttribute('y', cy - 35);
            box.setAttribute('width', 56);
            box.setAttribute('height', 70);
            box.setAttribute('fill', 'url(#outGrad)');
            box.setAttribute('stroke', '#f57d00');
            box.setAttribute('stroke-width', 1.5);
            box.setAttribute('rx', 3);
            g.appendChild(box);
            
            const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text1.setAttribute('x', x);
            text1.setAttribute('y', cy - 18);
            text1.setAttribute('text-anchor', 'middle');
            text1.setAttribute('font-size', '10');
            text1.setAttribute('font-weight', 'bold');
            text1.setAttribute('fill', 'white');
            text1.textContent = 'Output';
            g.appendChild(text1);
            
            const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text2.setAttribute('x', x);
            text2.setAttribute('y', cy + 8);
            text2.setAttribute('text-anchor', 'middle');
            text2.setAttribute('font-size', '8');
            text2.setAttribute('fill', 'white');
            text2.textContent = `${neurons}`;
            g.appendChild(text2);
            
            svg.appendChild(g);
        }

        function drawMLPLegend(svg, x, y) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            const items = [
                { label: 'Input', color: '#e8f5e9', stroke: '#2e7d32' },
                { label: 'Hidden', color: 'url(#hiddenGrad)', stroke: '#c5221f' },
                { label: 'Output', color: 'url(#outGrad)', stroke: '#f57d00' }
            ];
            
            let yOffset = y;
            items.forEach(item => {
                const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                box.setAttribute('x', x);
                box.setAttribute('y', yOffset);
                box.setAttribute('width', 10);
                box.setAttribute('height', 10);
                box.setAttribute('fill', item.color);
                box.setAttribute('stroke', item.stroke);
                box.setAttribute('stroke-width', 0.5);
                box.setAttribute('rx', 2);
                g.appendChild(box);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x + 14);
                text.setAttribute('y', yOffset + 8);
                text.setAttribute('font-size', '9');
                text.setAttribute('fill', '#333');
                text.textContent = item.label;
                g.appendChild(text);
                
                yOffset += 13;
            });
            
            svg.appendChild(g);
        }
    </script>
</body>

</html>
